# -*- coding: utf-8 -*-
"""Internship.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PKHl68EQEfjNHFDLZz7c-UOZJ9JDtFv_

# Optimization with quadratic datasets

Uploading of the file
"""

import time
import numpy as np
from google.colab import files
#First we download this provided dataset https://github.com/dwave-examples/knapsack/blob/master/data/very_large.csv
#And then we upload it here
uploaded = files.upload()  # Opens a file upload dialog

file = "100_WR_R_DR_25.txt"

"""###Loading of the new file"""

# First thing: we define a function which takes our dataset as a text file and returns the parameters for our model: coefficients (both quadratic and none), weights and capacity
def load_qkp_data(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    # Parse number of items (n)
    n = int(lines[0].strip())

    # Parse profit matrix P (n x n)
    P = np.zeros((n, n), dtype=int)
    diag_row = list(map(int, lines[1].strip().split()))
    for i in range(n):
        P[i][i] = diag_row[i]
        row = list(map(int, lines[i+2].strip().split())) #in ordine: prendo la linea di testo, rimuovo gli spazi, suddivido ogni numero in un elemento della lista, e lo converto a numero intero
        P[i][i+1:] = row

    # Parse weights and capacity
    weights = list(map(int, lines[-1].strip().split()))  # Last line is weights
    C = int(lines[-2].strip())  # Capacity is the second last value

    return P, weights, C

P, w, C = load_qkp_data("100_WR_R_DR_25.txt")
print(P)
print(w)
print(C)

"""#Smaller dataset

I'll try to get a smaller dataset from the big one: just by taking only one quarter of the variables of the big one. We creat a function ad hoc to divide the dataset
"""

import time
import numpy as np
from google.colab import files
#First we download this provided dataset https://github.com/dwave-examples/knapsack/blob/master/data/very_large.csv
#And then we upload it here
uploaded = files.upload()  # Opens a file upload dialog

file = "100_WR_M_DR_100.txt"

# First thing: we define a function which takes our dataset as a text file and returns the parameters for our model: coefficients (both quadratic and none), weights and capacity
def divide_qkp_data(filename, param = 5):
    with open(filename, 'r') as file:
        lines = file.readlines()

    # Parse number of items (n/5)
    N = int(lines[0].strip())
    n = N//param
    # Parse profit matrix P (n x n)
    P = np.zeros((n, n), dtype=int)
    diag_row = list(map(int, lines[1].strip().split()))
    for i in range(n):
        P[i][i] = diag_row[i]
        row = list(map(int, lines[i+2].strip().split())) #in ordine: prendo la linea di testo, rimuovo gli spazi, suddivido ogni numero in un elemento della lista, e lo converto a numero intero
        P[i][i+1:] = row[:n-i-1]

    # Parse weights and capacity
    weights = list(map(int, lines[-1].strip().split()))  # Last line is weights
    C = int(lines[-2].strip())
    tightness = C / sum(weights)
    weights_1 = weights [-n:]
    #print(weights_1)
    C_new = int(tightness * sum(weights_1))
    #w = [(param//2)*x // param for x in weights_1]
    #C = int(lines[-2].strip())//param  # Capacity is the second last value

    return P, weights_1, C_new

P, w, C = divide_qkp_data("100_WR_M_DR_100.txt",7)
print(P)
print(w)
print(C)

"""# Methods

###ExactPolySolver and Exact Solver
"""

!pip install dwave-ocean-sdk
import dimod
from dimod import BinaryQuadraticModel

"""PolySolver"""

from dimod import ExactPolySolver
import numpy as np
def solve_qkp_with_polysolver(P, w, C, lambda_penalty=None):
    n = len(w)

    if lambda_penalty is None:
        lambda_penalty = np.max(P)*10
    #Slack variables (computing the coefficients)
    max_slack = C - min(w)
    slack_bits = int(np.ceil(np.log2(max_slack + 1)))  # n° di bit per rappresentare lo slack
    z_weights = [1 << i for i in range(slack_bits)]  # es: [1, 2, 4]

    # Build BQM as Polynomial
    bqm = BinaryQuadraticModel("BINARY")
    # Profit terms
    for i in range(n):
      bqm.add_variable(f"x_{i}", -P[i, i])  # Linear terms
      for j in range(i + 1, n):  # Upper triangle only
          bqm.add_interaction(f"x_{i}", f"x_{j}", -P[i, j])  # Quadratic terms (already symmetric)

    # Penalty terms
    for i in range(n):
        bqm.add_variable(f"x_{i}", lambda_penalty * (w[i]*w[i] - 2*w[i]* C))

    for k in range(slack_bits):
      bqm.add_variable(f"z_{k}", lambda_penalty * (z_weights[k]*z_weights[k] - 2*z_weights[k]* C))

    for i in range(n):
        for j in range(i + 1, n):
            bqm.add_interaction(f"x_{i}", f"x_{j}", 2 * lambda_penalty * w[i] * w[j])

    for k in range(slack_bits):
      for h in range(k + 1, slack_bits):
          bqm.add_interaction(f"z_{k}", f"z_{h}", 2 * lambda_penalty * z_weights[k]* z_weights[h])

    for i in range(n):
      for k in range(slack_bits):
            bqm.add_interaction(f"x_{i}", f"z_{k}", 2 * lambda_penalty * w[i] * z_weights[k])

        # Use ExactSolver
    #sampler = ExactSolver()
    #sampleset = sampler.sample(bqm)
    sampler = ExactPolySolver()

    start_time = time.time()
    sampleset = sampler.sample_poly(bqm)
    runtime = time.time() - start_time

    best_sample = sampleset.first.sample
    best_energy = sampleset.first.energy

    selected_items = [int(var.split('_')[1]) for var, val in best_sample.items() if val == 1 and var.startswith("x_")]
    #print(best_sample.items())
    total_weight = sum(w[i] for i in selected_items)
    total_profit = sum(P[i, j] for i in selected_items for j in selected_items)

    return selected_items, total_weight, total_profit, runtime, best_energy

# For small problems (up to ~20 variables)
selected_items, total_weight, total_profit, runtime, best_energy = solve_qkp_with_polysolver(P, w, C)

print("Selected items:", selected_items)
print("Total weight:", total_weight, "/", C)
print("Total profit:", total_profit)
print("Feasible?", "Yes" if total_weight <= C else "No")
print("Best energy:", best_energy)
print("Runtime:", runtime)

runtimes = np.zeros(10)
for i in range(10):
  _, _, _, runtimes[i], _ = solve_qkp_with_polysolver(P, w, C)

print(runtimes)
print("Average runtime:", np.mean(runtimes))
print("Standard deviation of runtimes:", np.std(runtimes))

runtimes = np.zeros(10)
for i in range(10):
  _, _, _, runtimes[i], _ = solve_qkp_with_polysolver(P, w, C)

print(runtimes)
print("Average runtime:", np.mean(runtimes))
print("Standard deviation of runtimes:", np.std(runtimes))

"""ExactSolver"""

from dimod.reference.samplers import ExactSolver
import numpy as np
def solve_qkp_with_exactsolver(P, w, C, lambda_penalty=None):
    n = len(w)

    if lambda_penalty is None:
        lambda_penalty = np.max(P)*10
    #Slack variables (computing the coefficients)
    max_slack = C - min(w)
    slack_bits = int(np.ceil(np.log2(max_slack + 1)))  # n° di bit per rappresentare lo slack
    z_weights = [1 << i for i in range(slack_bits)]  # es: [1, 2, 4]

    # Build BQM as Polynomial
    bqm = BinaryQuadraticModel("BINARY")
    # Profit terms
    for i in range(n):
      bqm.add_variable(f"x_{i}", -P[i, i])  # Linear terms
      for j in range(i + 1, n):  # Upper triangle only
          bqm.add_interaction(f"x_{i}", f"x_{j}", -P[i, j])  # Quadratic terms (already symmetric)

    # Penalty terms
    for i in range(n):
        bqm.add_variable(f"x_{i}", lambda_penalty * (w[i]*w[i] - 2*w[i]* C))

    for k in range(slack_bits):
      bqm.add_variable(f"z_{k}", lambda_penalty * (z_weights[k]*z_weights[k] - 2*z_weights[k]* C))

    for i in range(n):
        for j in range(i + 1, n):
            bqm.add_interaction(f"x_{i}", f"x_{j}", 2 * lambda_penalty * w[i] * w[j])

    for k in range(slack_bits):
      for h in range(k + 1, slack_bits):
          bqm.add_interaction(f"z_{k}", f"z_{h}", 2 * lambda_penalty * z_weights[k]* z_weights[h])

    for i in range(n):
      for k in range(slack_bits):
            bqm.add_interaction(f"x_{i}", f"z_{k}", 2 * lambda_penalty * w[i] * z_weights[k])

    # Use ExactSolver
    #print(bqm)
    sampler = ExactSolver()

    start_time = time.time()
    sampleset = sampler.sample(bqm)
    runtime = time.time() - start_time
    #print(sampleset)

    best_sample = sampleset.first.sample
    best_energy = sampleset.first.energy

    selected_items = [int(var.split('_')[1]) for var, val in best_sample.items() if val == 1 and var.startswith("x_")]
    print(selected_items)
    total_weight = sum(w[i] for i in selected_items)
    total_profit = sum(P[i, j] for i in selected_items for j in selected_items)

    return selected_items, total_weight, total_profit, runtime, best_energy

# For small problems (up to ~20 variables)
selected_items, total_weight, total_profit, runtime, best_energy = solve_qkp_with_exactsolver(P, w, C)

print("Selected items:", selected_items)
print("Total weight:", total_weight, "/", C)
print("Total profit:", total_profit)
print("Feasible?", "Yes" if total_weight <= C else "No")
print("Best energy:", best_energy)
print("Runtime:", runtime)

runtimes = np.zeros(10)

print(runtimes)
for i in range(10):
  _, _, _, runtimes[i], _ = solve_qkp_with_polysolver(P, w, C)

mean = np.mean(runtimes)
std = np.std(runtimes)
print("Average runtime:", mean)
print("Standard deviation of runtimes:", std)

"""###Other way to obtain a dataset"""

#Other possible ways to generate the dataset
bqm = dimod.generators.gnp_random_bqm(20, 0.5, 'BINARY')
    # it generates a dataset randomly with a given probability 0.5 to have quadratic interactions
bqm2 = dimod.generators.knapsack(100) #fare prova

"""### Simulated Annealing and Tabu Search"""

from dwave.samplers import SimulatedAnnealingSampler
from dwave.samplers import TabuSampler

"""Meaning of the inputs: First, we recall that β = 1/T, where T is the temperature. Start the annealing at β = 0.1 (left extreme of the interval) (high temperature and high randomness) End the annealing at β = 4.2 (right extreme of the interval) (low temperature, focused on low energy)

beta_schedule_type='linear': Linearly increase β from 0.1 to 4.2 over the annealing process (i.e., gradually cool the system). Another possible option could have been 'geometric'.

num_sweeps: Each sweep is one full pass over all variables (flipping them one by one to reduce energy). More sweeps → longer and deeper local search → potentially better-quality solutions.

num_reads: number of independent solution attempts
"""

# SIMULATED ANNEALING
def solve_qkp_with_SA(P, w, C, lambda_penalty=None, num_reads=1000000):
    n = len(w)

    if lambda_penalty is None:
        lambda_penalty = np.max(P)*100
    #Slack variables (computing the coefficients)
    max_slack = C - min(w)
    slack_bits = int(np.ceil(np.log2(max_slack + 1)))  # n° di bit per rappresentare lo slack
    z_weights = [1 << i for i in range(slack_bits)]  # es: [1, 2, 4]

    # Build BQM as Polynomial
    bqm = BinaryQuadraticModel("BINARY")
    # Profit terms
    for i in range(n):
      bqm.add_variable(f"x_{i}", -P[i, i])  # Linear terms
      for j in range(i + 1, n):  # Upper triangle only
          bqm.add_interaction(f"x_{i}", f"x_{j}", -P[i, j])  # Quadratic terms (already symmetric)

    # Penalty terms
    for i in range(n):
        bqm.add_variable(f"x_{i}", lambda_penalty * (w[i]*w[i] - 2*w[i]* C))

    for k in range(slack_bits):
      bqm.add_variable(f"z_{k}", lambda_penalty * (z_weights[k]*z_weights[k] - 2*z_weights[k]* C))

    for i in range(n):
        for j in range(i + 1, n):
            bqm.add_interaction(f"x_{i}", f"x_{j}", 2 * lambda_penalty * w[i] * w[j])

    for k in range(slack_bits):
      for h in range(k + 1, slack_bits):
          bqm.add_interaction(f"z_{k}", f"z_{h}", 2 * lambda_penalty * z_weights[k]* z_weights[h])

    for i in range(n):
      for k in range(slack_bits):
            bqm.add_interaction(f"x_{i}", f"z_{k}", 2 * lambda_penalty * w[i] * z_weights[k])


    # Run Simulated Annealing
    sampler = SimulatedAnnealingSampler()

    start_time = time.time()
    sampleset =  sampler.sample(
    bqm,
    num_reads=500000,
    #beta_range=[0.1, 5.0],
    beta_schedule_type='linear',
    num_sweeps=5000)
    runtime = time.time() - start_time

    # Get best solution
    best_sample = sampleset.first.sample
    best_energy = sampleset.first.energy
    selected_items = [int(var.split('_')[1]) for var, val in best_sample.items() if val == 1 and var.startswith("x_")]
    total_weight = sum(w[i] for i in selected_items)
    total_profit = sum(P[i, j] for i in selected_items for j in selected_items)

    return selected_items, total_weight, total_profit, runtime, best_energy

# Solve QKP with Simulated Annealing
selected_items, total_weight, total_profit, runtime, best_energy = solve_qkp_with_SA(P, w, C, num_reads=5000)

# Output results
print("Selected items (indices):", selected_items)
print("Total weight:", total_weight, "/", C)
print("Total profit:", total_profit)
print("Feasible?", "Yes" if total_weight <= C else "No")
print("Runtime:", runtime, "seconds")
print("Best energy:", best_energy)

runtimes = np.zeros(10)
for i in range(10):
  _, _, _, runtimes[i], _ = solve_qkp_with_SA(P, w, C)

mean = np.mean(runtimes)
std = np.std(runtimes)
print("Average runtime:", mean)
print("Standard deviation of runtimes:", std)

# TABU SEARCH
def solve_qkp_with_TS(P, w, C, lambda_penalty=None, num_reads=10000, tenure=1):
    n = len(w)

    if lambda_penalty is None:
        lambda_penalty = np.max(P)*100
    #Slack variables (computing the coefficients)
    max_slack = C - min(w)
    slack_bits = int(np.ceil(np.log2(max_slack + 1)))  # n° di bit per rappresentare lo slack
    z_weights = [1 << i for i in range(slack_bits)]  # es: [1, 2, 4]

    # Build BQM as Polynomial
    bqm = BinaryQuadraticModel("BINARY")
    # Profit terms
    for i in range(n):
      bqm.add_variable(f"x_{i}", -P[i, i])  # Linear terms
      for j in range(i + 1, n):  # Upper triangle only
          bqm.add_interaction(f"x_{i}", f"x_{j}", -P[i, j])  # Quadratic terms (already symmetric)

    # Penalty terms
    for i in range(n):
        bqm.add_variable(f"x_{i}", lambda_penalty * (w[i]*w[i] - 2*w[i]* C))

    for k in range(slack_bits):
      bqm.add_variable(f"z_{k}", lambda_penalty * (z_weights[k]*z_weights[k] - 2*z_weights[k]* C))

    for i in range(n):
        for j in range(i + 1, n):
            bqm.add_interaction(f"x_{i}", f"x_{j}", 2 * lambda_penalty * w[i] * w[j])

    for k in range(slack_bits):
      for h in range(k + 1, slack_bits):
          bqm.add_interaction(f"z_{k}", f"z_{h}", 2 * lambda_penalty * z_weights[k]* z_weights[h])

    for i in range(n):
      for k in range(slack_bits):
            bqm.add_interaction(f"x_{i}", f"z_{k}", 2 * lambda_penalty * w[i] * z_weights[k])

    # Run Simulated Annealing
    sampler = TabuSampler()

    start_time = time.time()
    sampleset = sampler.sample(bqm, num_reads= num_reads, tenure= tenure, initial_states=None, timeout=None)
    runtime = time.time() - start_time

    # Get best solution
    best_sample = sampleset.first.sample
    best_energy = sampleset.first.energy
    selected_items = [int(var.split('_')[1]) for var, val in best_sample.items() if val == 1]
    total_weight = sum(w[i] for i in selected_items)
    total_profit = sum(P[i, j] for i in selected_items for j in selected_items)

    return selected_items, total_weight, total_profit, runtime, best_energy

# Solve QKP with TabuSearch
selected_items, total_weight, total_profit, runtime, best_energy = solve_qkp_with_TS(P, w, C, num_reads=100)

# Output results
print("Selected items (indices):", selected_items)
print("Total weight:", total_weight, "/", C)
print("Total profit:", total_profit)
print("Feasible?", "Yes" if total_weight <= C else "No")
print("Runtime:", runtime, "seconds")
print("Best energy:", best_energy)

runtimes = np.zeros(10)

for i in range(10):
  _, _, _, runtimes[i], _ = solve_qkp_with_TS(P, w, C, num_read = 100)

mean = np.mean(runtimes)
std = np.std(runtimes)
print("Average runtime:", mean)
print("Standard deviation of runtimes:", std)

"""### Gurobi"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install gurobipy
import gurobipy as gp
from gurobipy import GRB

# Solving using Gurobi
def solve_qkp_with_Gurobi(P, w, C):

    # Create Gurobi model
    model = gp.Model("QKP")
    model.setParam('OutputFlag', 1)  # Enable solver output: very useful to obtain infos while solving
    #model.setParam('TimeLimit', 600)  # Limit to 10 minutes (adjust as needed)
    #model.setParam('MIPGap', 0.75)   # Accept 5% optimality gap (faster termination)
    model.setParam('Threads', 8)     # Use more CPU cores if available
    model.setParam('Presolve', 2)       # Aggressive presolve
    model.setParam('Heuristics', 0.5)   # Spend more time on heuristics
    model.setParam('Cuts', 2)           # Generate aggressive cuts

    n = len(w)
    # Add binary variables
    x = model.addVars(n, vtype=GRB.BINARY, name="x")
    # Set objective: maximize sum_{i,j} P[i][j] * x[i] * x[j]
    objective = gp.QuadExpr() #Necessary for a quadratic expression
    for i in range(n):
        for j in range(n):
            if P[i][j] != 0:  # Skip zero terms for efficiency
                objective += P[i][j] * x[i] * x[j]
    model.setObjective(objective, GRB.MAXIMIZE)
    # Add knapsack constraint: sum_i w[i] * x[i] <= C
    model.addConstr(gp.quicksum(w[i] * x[i] for i in range(n)) <= C, "KnapsackConstraint")

    # Start solution
    x_start = [0] * n
    for i in sorted(range(n), key=lambda i: -P[i][i]/w[i]):
      if w[i] <= C:
        x_start[i] = 1
        C -= w[i]
    # Set the starting solution
    for i in range(n):
      x[i].Start = x_start[i]

    # Optimize the model
    start_time = time.time()
    model.optimize()
    runtime = time.time() - start_time

    # Extract solution
    if model.status == GRB.OPTIMAL:
        selected_items = [i for i in range(n) if x[i].X > 0.5]
        total_weight = sum(w[i] for i in selected_items)
        total_profit = model.ObjVal
       # total_energy = sum(P[i][j] for i in selected_items for j in selected_items)
        return selected_items, total_weight, total_profit, runtime# total_energy
    else:
        raise Exception("No optimal solution found.")

# Solve QKP with Gurobi
selected_items, total_weight, total_profit, runtime = solve_qkp_with_Gurobi(P, w, C)

# Print results
print("Selected items (indices):", selected_items)
print("Total weight:", total_weight, "/", C)
print("Total profit:", total_profit)
print("Feasible?", "Yes" if total_weight <= C else "No")
print("Runtime:", runtime, "seconds")

"""Remark: from the test mad on this small dataset, it seems Gurobi find a better result, in terms of profit, than the other 2 methods: ExactPolySolver and SA. Why? It could be for the presence of big penalties in the 2 methods?"""

runtimes = np.zeros(10)
for i in range(10):
  _, _, _, runtimes[i]= solve_qkp_with_Gurobi(P, w, C)

mean = np.mean(runtimes)
std = np.std(runtimes)
print("Average runtime:", mean)
print("Standard deviation of runtimes:", std)

"""##Gurobi with QUBO formulation

"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install gurobipy
import gurobipy as gp
from gurobipy import GRB

import gurobipy as gp
from gurobipy import GRB
import numpy as np
import time

def solve_qkp_Gurobi_with_QUBO(P, w, C, lambda_penalty=None):
    n = len(w)

    if lambda_penalty is None:
        lambda_penalty = np.max(P) * 0.5

    # Slack variable encoding (binary encoding of slack)
    max_slack = C - min(w)
    slack_bits = int(np.ceil(np.log2(max_slack + 1)))
    z_weights = [1 << i for i in range(slack_bits)]  # Powers of 2: 1, 2, 4, ...

    model = gp.Model("QKP_Gurobi_with_QUBO")
    model.setParam('OutputFlag', 1)  # Enable solver output: very useful to obtain infos while solving
    #model.setParam('TimeLimit', 600)  # Limit to 10 minutes (adjust as needed)
    #model.setParam('MIPGap', 0.01)   # Accept 5% optimality gap (faster termination)
    model.setParam('Threads', 8)     # Use more CPU cores if available
    model.setParam('Presolve', 2)       # Aggressive presolve
    #model.setParam('Heuristics', 0.5)   # Spend more time on heuristics
    #model.setParam('Cuts', 2)           # Generate aggressive cuts

    # Variables
    x = model.addVars(n, vtype=GRB.BINARY, name="x")
    z = model.addVars(slack_bits, vtype=GRB.BINARY, name="z")

    # QUBO Objective: same logic as your SA version
    obj = gp.QuadExpr()

    # 1. Profit terms: -xᵀ P x
    for i in range(n):
        obj.add(-P[i, i] * x[i])  # linear
        for j in range(i + 1, n):
            obj.add(-P[i, j] * x[i] * x[j])  # quadratic

    # 2. Penalty linear terms
    for i in range(n):
        obj.add(lambda_penalty * (w[i]**2 - 2 * w[i] * C) * x[i])
    for k in range(slack_bits):
        obj.add(lambda_penalty * (z_weights[k]**2 - 2 * z_weights[k] * C) * z[k])

    # 3. Penalty quadratic terms (x-x)
    for i in range(n):
        for j in range(i + 1, n):
            obj.add(2 * lambda_penalty * w[i] * w[j] * x[i] * x[j])

    # 4. Penalty quadratic terms (z-z)
    for k in range(slack_bits):
        for h in range(k + 1, slack_bits):
            obj.add(2 * lambda_penalty * z_weights[k] * z_weights[h] * z[k] * z[h])

    # 5. Penalty cross terms (x-z)
    for i in range(n):
        for k in range(slack_bits):
            obj.add(2 * lambda_penalty * w[i] * z_weights[k] * x[i] * z[k])

    # Set objective
    model.setObjective(obj, GRB.MINIMIZE)  # MIN because of negative profits

    # Optimize
    start_time = time.time()
    model.optimize()
    runtime = time.time() - start_time

    # Recover solution
    if model.status == GRB.OPTIMAL or model.status == GRB.SUBOPTIMAL:
        selected_items = [i for i in range(n) if x[i].X > 0.5]
        total_weight = sum(w[i] for i in selected_items)
        total_profit = sum(P[i, j] for i in selected_items for j in selected_items)
        #best_energy = model.ObjVal
        return selected_items, total_weight, total_profit, runtime
    else:
        raise Exception("No (sub)optimal solution found.")

# Solve QKP with Gurobi
selected_items, total_weight, total_profit, runtime = solve_qkp_Gurobi_with_QUBO(P, w, C)

# Print results
print("Selected items (indices):", selected_items)
print("Total weight:", total_weight, "/", C)
print("Total profit:", total_profit)
print("Feasible?", "Yes" if total_weight <= C else "No")
print("Runtime:", runtime, "seconds")

runtimes = np.zeros(10)
for i in range(10):
  _, _, _, runtimes[i]= solve_qkp_Gurobi_with_QUBO(P, w, C)

mean = np.mean(runtimes)
std = np.std(runtimes)
print("Average runtime:", mean)
print("Standard deviation of runtimes:", std)

"""##QAOA (with cudaQ)

"""

!pip install cudaq

import numpy as np
import cudaq
from scipy.optimize import minimize
import time
from cudaq import spin
from typing import List

def compute_qkp_coefficients(P, w, C, lambda_penalty):
    n = len(w)  # Number of items
    slack_bits = int(np.ceil(np.log2(C + 1)))  # Bits needed for slack
    z_weights = [2**k for k in range(slack_bits)]  # Slack bit weights [1, 2, 4, ...]

    # --- Linear coefficients ---
    coeff_linear_x = [
        float(-P[i, i] + lambda_penalty * w[i] * (w[i] - 2 * C))
        for i in range(n)
    ]
    coeff_linear_s = [
        float(lambda_penalty * ( (2**k)**2 - 2 * (2**k) * C ))
        for k in range(slack_bits)
    ]

    # --- Quadratic coefficients ---
    coeff_quad_xx = []  # Item-item terms (i < j)
    for i in range(n):
        for j in range(i + 1, n):
            coeff_quad_xx.append(float(-P[i, j] + 2 * lambda_penalty * w[i] * w[j]))

    coeff_quad_xs = []  # Item-slack terms (all i, all k)
    for i in range(n):
        for k in range(slack_bits):
            coeff_quad_xs.append(float(2 * lambda_penalty * w[i] * (2**k)))

    coeff_quad_ss = []  # Slack-slack terms (k < h)
    for k in range(slack_bits):
        for h in range(k + 1, slack_bits):
            coeff_quad_ss.append(float(2 * lambda_penalty * (2**k) * (2**h)))

    return {
        "linear_x": coeff_linear_x,
        "linear_s": coeff_linear_s,
        "quad_xx": coeff_quad_xx,
        "quad_xs": coeff_quad_xs,
        "quad_ss": coeff_quad_ss,
    }

"""Small Datasets"""

#Dimension = 4
C = 7
w = [2, 3, 4, 5]
P = np.array([
    [10, 10, 4, 0],
    [0, 8, 6, 2],
    [0, 0, 6, 8],
    [0, 0, 0, 7]
])
print(P)

#Dimension = 5
C = 9
w = [3, 2, 3, 4, 5]
P = np.array([
    [7, 4, 6, 7, 0],
    [0, 10, 10, 4, 0],
    [0, 0, 8, 6, 2],
    [0, 0, 0, 6, 8],
    [0, 0, 0, 0, 7]
])
print(P)

#Dimension = 6
C = 11
w = [4, 3, 2, 3, 4, 5]
P = np.array([
    [9, 11, 6, 8, 5, 0],
    [0, 7, 4, 6, 7, 0],
    [0, 0, 10, 10, 4, 0],
    [0, 0, 0, 8, 6, 2],
    [0, 0, 0, 0, 6, 8],
    [0, 0, 0, 0, 0, 7]
])
print(P)

#Dimension = 6
C = 12
w = [2, 3, 4, 5, 6, 7]

P = np.array([
    [15, 5,  3,  2,  0,  0],
    [0,  20, 6,  4,  1,  0],
    [0,  0,  18, 5,  3,  0],
    [0,  0,  0,  25, 8,  4],
    [0,  0,  0,  0,  12, 6],
    [0,  0,  0,  0,  0,  10]
])

#Dimension = 8
C = 20
w = [3, 4, 5, 5, 6, 7, 8, 9]

P = np.array([
    [20, 8,  6,  5,  0,  0,  0,  0],
    [0,  25, 10, 7,  4,  0,  0,  0],
    [0,  0,  30, 12, 8,  5,  0,  0],
    [0,  0,  0,  35, 15, 9,  6,  0],
    [0,  0,  0,  0,  18, 10, 7,  4],
    [0,  0,  0,  0,  0,  22, 12, 8],
    [0,  0,  0,  0,  0,  0,  15, 10],
    [0,  0,  0,  0,  0,  0,  0,  12]
])

lambda_penalty = np.max(P) *35 +1

# Precompute all coefficients
coefficients = compute_qkp_coefficients(P, w, C, lambda_penalty)
print(coefficients)

def solve_qkp_with_QAOA(P, w, C, coefficients, lambda_penalty=lambda_penalty,p=1, num_shots=5000):
  n = len(w)
  #lambda_penalty = np.max(P) * 1000  # Heuristic: ensure penalty dominates
  # Slack variables setup
  max_slack = max(C - min(w), 0)  # Prevent negative values
  slack_bits = int(np.ceil(np.log2(max_slack + 1)))
  z_weights = [2**i for i in range(slack_bits)]  # Binary weights for slack
  coefficients = compute_qkp_coefficients(P, w, C, lambda_penalty)
  linear_x = coefficients["linear_x"]
  linear_s = coefficients["linear_s"]
  quad_xx = coefficients["quad_xx"]
  quad_xs = coefficients["quad_xs"]
  quad_ss = coefficients["quad_ss"]

  # Total qubits: n (items) + slack_bits
  total_qubits = n + slack_bits

  # Build the Hamiltonian
  hamiltonian = cudaq.SpinOperator()

  for i in range(n):
    hamiltonian += linear_x[i] * spin.z(i)

  for k in range(slack_bits):
    hamiltonian += linear_s[k] * spin.z(n + k)

  index = 0
  for i in range(n):
    for j in range(i + 1, n):
      hamiltonian += quad_xx[index] * spin.z(i) * spin.z(j)
      index += 1

  index = 0
  for i in range(n):
    for k in range(slack_bits):
      hamiltonian += quad_xs[index] * spin.z(i) * spin.z(n+k)
      index += 1

  index = 0
  for k in range(slack_bits):
    for h in range(k + 1, slack_bits):
      hamiltonian +=  quad_ss[index]* spin.z(n + k) * spin.z(n + h)
      index += 1
  def fourier_init(p, freq=1):
    t = np.arange(1, p + 1)
    gamma = np.pi / 4 + 0.1 * np.sin(freq * np.pi * t / p)
    beta  = np.pi / 8 + 0.1 * np.cos(freq * np.pi * t / p)
    return np.concatenate([gamma, beta])
  def problem_informed_init(p):
    gamma = np.full(p, 0.3 * np.sqrt(C / (np.mean(w) * len(w))))
    beta = np.full(p, np.pi/4)
    return np.concatenate([gamma, beta])
  @cudaq.kernel
  def qaoa_ansatz(
      gammas: list[float],
      betas: list[float],
      linear_x: list[float],
      linear_s: list[float],
      quad_xx: list[float],
      quad_xs: list[float],
      quad_ss: list[float],
      p: int,
      ):
    q = cudaq.qvector(total_qubits)

    # Initial Hadamard layer
    h(q)

    for layer in range(p):
      gamma = gammas[layer]
      beta = betas[layer]

      #  Cost Unitary (exp(-iγH))
      # 1. Linear terms (x_i)
      for i in range(n):
        rz(2.0 * gamma * linear_x[i], q[i])

      # 2. Linear terms (s_k)
      for k in range(slack_bits):
        rz(2.0 * gamma * linear_s[k], q[n + k])

      # 3. Quadratic terms (x_i x_j)
      idx = 0
      for i in range(n):
        for j in range(i + 1, n):
          cx(q[i], q[j])
          rz(2.0 * gamma * quad_xx[idx], q[j])
          cx(q[i], q[j])
          idx += 1

      # 4. Quadratic terms (x_i s_k)
      idx = 0
      for i in range(n):
        for k in range(slack_bits):
          cx(q[i], q[n + k])
          rz(2.0 * gamma * quad_xs[idx], q[n + k])
          cx(q[i], q[n + k])
          idx += 1

      # 5. Quadratic terms (s_k s_h)
      idx = 0
      for k in range(slack_bits):
        for h in range(k + 1, slack_bits):
          cx(q[n + k], q[n + h])
          rz(2.0 * gamma * quad_ss[idx], q[n + h])
          cx(q[n + k], q[n + h])
          idx += 1

      # --- Mixer Unitary (exp(-iβΣX)) ---
      for i in range(total_qubits):
        rx(2.0 * beta, q[i])

  def expectation(params):
    # Split params into gammas and betas
    gammas = params[:p]
    betas = params[p:]
    return cudaq.observe(
        qaoa_ansatz,
        hamiltonian,  # Your pre-built SpinOperator
        gammas,
        betas,
        coefficients["linear_x"],
        coefficients["linear_s"],
        coefficients["quad_xx"],
        coefficients["quad_xs"],
        coefficients["quad_ss"],
        p
    ).expectation()
    # Initial parameters
  #init_params_1 = np.random.uniform(0, np.pi, 2 * p)
  gamma = np.full(p, 0.85)
  beta  = np.full(p, 0.3)
  init_params_1 = np.concatenate([gamma,beta])
  init_params_2 = np.random.uniform(0, np.pi, 2 * p)
  init_params_3 = fourier_init(p, freq=1)
  init_params_4 = problem_informed_init(p)
  init_params = init_params_4

  avg_profit = np.mean(np.diag(P))
  avg_weight = np.mean(w)
  gamma_init = 0.5 * np.arcsin(np.sqrt(C / (avg_weight * len(w))))  # ~0.2-0.5
  beta_init = np.pi / 4  # Maximal mixing
  #init_params = np.concatenate([np.full(p, gamma_init), np.full(p, beta_init)])
  print("Initial parameters:", init_params)

  start_time = time.time()
  result = minimize(expectation, init_params, method='COBYLA')
  runtime = time.time() - start_time

  #samples = cudaq.sample(qaoa_ansatz, result.x[0], result.x[1], shots = num_shots )
  # Split the optimized parameters into gammas and betas
  optimized_gammas = result.x[:p]
  optimized_betas = result.x[p:]

  samples = cudaq.sample(qaoa_ansatz, optimized_gammas, optimized_betas, coefficients["linear_x"],
        coefficients["linear_s"],
        coefficients["quad_xx"],
        coefficients["quad_xs"],
        coefficients["quad_ss"],
        p,
        shots_count=num_shots,)
  # Process results
  best_sample = max(samples.items(), key=lambda x: x[1])[0]
  selected_indices = [i for i, bit in enumerate(best_sample) if bit == '1']
  new_indices = [i for i in selected_indices if i < len(w)]
  total_weight = sum(w[i] for i in new_indices)
  total_profit = sum(P[i][j] for i in new_indices for j in new_indices)

  return new_indices, total_weight, total_profit, runtime, result.fun

selected_indices, total_weight, total_profit, runtime, best_energy= solve_qkp_with_QAOA(P, w, C, coefficients, p = 2)

print("Selected items:", selected_indices)
print(f"Total weight: {total_weight} / {C} ({'Feasible' if total_weight <= C else 'Infeasible'})")
print("Total profit:", total_profit)
print(f"Runtime: {runtime:.2f} seconds")
print("Best energy:", best_energy)

"""# QAOA già fornito

"""

!pip install cudaq
import cudaq
from cudaq import spin

from typing import List

import numpy as np

# Here we build up a kernel for QAOA with `p` layers, with each layer
# containing the alternating set of unitaries corresponding to the problem
# and the mixer Hamiltonians. The algorithm leverages the VQE algorithm
# to compute the Max-Cut of a rectangular graph illustrated below.

#       v0  0---------------------0 v1
#           |                     |
#           |                     |
#           |                     |
#           |                     |
#       v3  0---------------------0 v2
# The Max-Cut for this problem is 0101 or 1010.

# The problem Hamiltonian
hamiltonian = 0.5 * spin.z(0) * spin.z(1) + 0.5 * spin.z(1) * spin.z(2) \
       + 0.5 * spin.z(0) * spin.z(3) + 0.5 * spin.z(2) * spin.z(3)

# Problem parameters.
qubit_count: int = 4
layer_count: int = 2
parameter_count: int = 2 * layer_count


@cudaq.kernel
def kernel_qaoa(qubit_count: int, layer_count: int, thetas: List[float]):
    """QAOA ansatz for Max-Cut"""
    qvector = cudaq.qvector(qubit_count)

    # Create superposition
    h(qvector)

    # Loop over the layers
    for layer in range(layer_count):
        # Loop over the qubits
        # Problem unitary
        for qubit in range(qubit_count):
            x.ctrl(qvector[qubit], qvector[(qubit + 1) % qubit_count])
            rz(2.0 * thetas[layer], qvector[(qubit + 1) % qubit_count])
            x.ctrl(qvector[qubit], qvector[(qubit + 1) % qubit_count])

        # Mixer unitary
        for qubit in range(qubit_count):
            rx(2.0 * thetas[layer + layer_count], qvector[qubit])


# Specify the optimizer and its initial parameters. Make it repeatable.
cudaq.set_random_seed(13)
optimizer = cudaq.optimizers.COBYLA()
np.random.seed(13)
optimizer.initial_parameters = np.random.uniform(-np.pi / 8.0, np.pi / 8.0,
                                                 parameter_count)
print("Initial parameters = ", optimizer.initial_parameters)


# Define the objective, return `<state(params) | H | state(params)>`
def objective(parameters):
    return cudaq.observe(kernel_qaoa, hamiltonian, qubit_count, layer_count,
                         parameters).expectation()


# Optimize!
optimal_expectation, optimal_parameters = optimizer.optimize(
    dimensions=parameter_count, function=objective)

# Print the optimized value and its parameters
print("Optimal value = ", optimal_expectation)
print("Optimal parameters = ", optimal_parameters)

# Sample the circuit using the optimized parameters
counts = cudaq.sample(kernel_qaoa, qubit_count, layer_count, optimal_parameters)
print(counts)