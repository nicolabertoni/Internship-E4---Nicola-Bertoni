# -*- coding: utf-8 -*-
"""QAOA (with CudaQ).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KvnwPeMkWI9PETr50xWRLwuQXNU1WHIg
"""

!pip install cudaq

import numpy as np
import cudaq
from scipy.optimize import minimize
import time
from cudaq import spin
from typing import List

def compute_qkp_coefficients(P, w, C, lambda_penalty):
    n = len(w)  # Number of items
    slack_bits = int(np.ceil(np.log2(C + 1)))  # Bits needed for slack
    z_weights = [2**k for k in range(slack_bits)]  # Slack bit weights [1, 2, 4, ...]

    # --- Linear coefficients ---
    coeff_linear_x = [
        float(-P[i, i] + lambda_penalty * w[i] * (w[i] - 2 * C))
        for i in range(n)
    ]
    coeff_linear_s = [
        float(lambda_penalty * ( (2**k)**2 - 2 * (2**k) * C ))
        for k in range(slack_bits)
    ]

    # --- Quadratic coefficients ---
    coeff_quad_xx = []  # Item-item terms (i < j)
    for i in range(n):
        for j in range(i + 1, n):
            coeff_quad_xx.append(float(-P[i, j] + 2 * lambda_penalty * w[i] * w[j]))

    coeff_quad_xs = []  # Item-slack terms (all i, all k)
    for i in range(n):
        for k in range(slack_bits):
            coeff_quad_xs.append(float(2 * lambda_penalty * w[i] * (2**k)))

    coeff_quad_ss = []  # Slack-slack terms (k < h)
    for k in range(slack_bits):
        for h in range(k + 1, slack_bits):
            coeff_quad_ss.append(float(2 * lambda_penalty * (2**k) * (2**h)))

    return {
        "linear_x": coeff_linear_x,
        "linear_s": coeff_linear_s,
        "quad_xx": coeff_quad_xx,
        "quad_xs": coeff_quad_xs,
        "quad_ss": coeff_quad_ss,
    }

"""Small Datasets"""

#Dimension = 4
C = 7
w = [2, 3, 4, 5]
P = np.array([
    [10, 10, 4, 0],
    [0, 8, 6, 2],
    [0, 0, 6, 8],
    [0, 0, 0, 7]
])
print(P)

#Dimension = 5
C = 9
w = [3, 2, 3, 4, 5]
P = np.array([
    [7, 4, 6, 7, 0],
    [0, 10, 10, 4, 0],
    [0, 0, 8, 6, 2],
    [0, 0, 0, 6, 8],
    [0, 0, 0, 0, 7]
])
print(P)

#Dimension = 6
C = 11
w = [4, 3, 2, 3, 4, 5]
P = np.array([
    [9, 11, 6, 8, 5, 0],
    [0, 7, 4, 6, 7, 0],
    [0, 0, 10, 10, 4, 0],
    [0, 0, 0, 8, 6, 2],
    [0, 0, 0, 0, 6, 8],
    [0, 0, 0, 0, 0, 7]
])
print(P)

#Dimension = 6
C = 12
w = [2, 3, 4, 5, 6, 7]

P = np.array([
    [15, 5,  3,  2,  0,  0],
    [0,  20, 6,  4,  1,  0],
    [0,  0,  18, 5,  3,  0],
    [0,  0,  0,  25, 8,  4],
    [0,  0,  0,  0,  12, 6],
    [0,  0,  0,  0,  0,  10]
])

#Dimension = 8
C = 20
w = [3, 4, 5, 5, 6, 7, 8, 9]

P = np.array([
    [20, 8,  6,  5,  0,  0,  0,  0],
    [0,  25, 10, 7,  4,  0,  0,  0],
    [0,  0,  30, 12, 8,  5,  0,  0],
    [0,  0,  0,  35, 15, 9,  6,  0],
    [0,  0,  0,  0,  18, 10, 7,  4],
    [0,  0,  0,  0,  0,  22, 12, 8],
    [0,  0,  0,  0,  0,  0,  15, 10],
    [0,  0,  0,  0,  0,  0,  0,  12]
])

lambda_penalty = np.max(P) *35 +1

# Precompute all coefficients
coefficients = compute_qkp_coefficients(P, w, C, lambda_penalty)
print(coefficients)

def solve_qkp_with_QAOA(P, w, C, coefficients, lambda_penalty=lambda_penalty,p=1, num_shots=5000):
  n = len(w)
  #lambda_penalty = np.max(P) * 1000  # Heuristic: ensure penalty dominates
  # Slack variables setup
  max_slack = max(C - min(w), 0)  # Prevent negative values
  slack_bits = int(np.ceil(np.log2(max_slack + 1)))
  z_weights = [2**i for i in range(slack_bits)]  # Binary weights for slack
  coefficients = compute_qkp_coefficients(P, w, C, lambda_penalty)
  linear_x = coefficients["linear_x"]
  linear_s = coefficients["linear_s"]
  quad_xx = coefficients["quad_xx"]
  quad_xs = coefficients["quad_xs"]
  quad_ss = coefficients["quad_ss"]

  # Total qubits: n (items) + slack_bits
  total_qubits = n + slack_bits

  # Build the Hamiltonian
  hamiltonian = cudaq.SpinOperator()

  for i in range(n):
    hamiltonian += linear_x[i] * spin.z(i)

  for k in range(slack_bits):
    hamiltonian += linear_s[k] * spin.z(n + k)

  index = 0
  for i in range(n):
    for j in range(i + 1, n):
      hamiltonian += quad_xx[index] * spin.z(i) * spin.z(j)
      index += 1

  index = 0
  for i in range(n):
    for k in range(slack_bits):
      hamiltonian += quad_xs[index] * spin.z(i) * spin.z(n+k)
      index += 1

  index = 0
  for k in range(slack_bits):
    for h in range(k + 1, slack_bits):
      hamiltonian +=  quad_ss[index]* spin.z(n + k) * spin.z(n + h)
      index += 1
  def fourier_init(p, freq=1):
    t = np.arange(1, p + 1)
    gamma = np.pi / 4 + 0.1 * np.sin(freq * np.pi * t / p)
    beta  = np.pi / 8 + 0.1 * np.cos(freq * np.pi * t / p)
    return np.concatenate([gamma, beta])
  def problem_informed_init(p):
    gamma = np.full(p, 0.3 * np.sqrt(C / (np.mean(w) * len(w))))
    beta = np.full(p, np.pi/4)
    return np.concatenate([gamma, beta])
  @cudaq.kernel
  def qaoa_ansatz(
      gammas: list[float],
      betas: list[float],
      linear_x: list[float],
      linear_s: list[float],
      quad_xx: list[float],
      quad_xs: list[float],
      quad_ss: list[float],
      p: int,
      ):
    q = cudaq.qvector(total_qubits)

    # Initial Hadamard layer
    h(q)

    for layer in range(p):
      gamma = gammas[layer]
      beta = betas[layer]

      #  Cost Unitary (exp(-iγH))
      # 1. Linear terms (x_i)
      for i in range(n):
        rz(2.0 * gamma * linear_x[i], q[i])

      # 2. Linear terms (s_k)
      for k in range(slack_bits):
        rz(2.0 * gamma * linear_s[k], q[n + k])

      # 3. Quadratic terms (x_i x_j)
      idx = 0
      for i in range(n):
        for j in range(i + 1, n):
          cx(q[i], q[j])
          rz(2.0 * gamma * quad_xx[idx], q[j])
          cx(q[i], q[j])
          idx += 1

      # 4. Quadratic terms (x_i s_k)
      idx = 0
      for i in range(n):
        for k in range(slack_bits):
          cx(q[i], q[n + k])
          rz(2.0 * gamma * quad_xs[idx], q[n + k])
          cx(q[i], q[n + k])
          idx += 1

      # 5. Quadratic terms (s_k s_h)
      idx = 0
      for k in range(slack_bits):
        for h in range(k + 1, slack_bits):
          cx(q[n + k], q[n + h])
          rz(2.0 * gamma * quad_ss[idx], q[n + h])
          cx(q[n + k], q[n + h])
          idx += 1

      # --- Mixer Unitary (exp(-iβΣX)) ---
      for i in range(total_qubits):
        rx(2.0 * beta, q[i])

  def expectation(params):
    # Split params into gammas and betas
    gammas = params[:p]
    betas = params[p:]
    return cudaq.observe(
        qaoa_ansatz,
        hamiltonian,  # Your pre-built SpinOperator
        gammas,
        betas,
        coefficients["linear_x"],
        coefficients["linear_s"],
        coefficients["quad_xx"],
        coefficients["quad_xs"],
        coefficients["quad_ss"],
        p
    ).expectation()
    # Initial parameters
  #init_params_1 = np.random.uniform(0, np.pi, 2 * p)
  gamma = np.full(p, 0.85)
  beta  = np.full(p, 0.3)
  init_params_1 = np.concatenate([gamma,beta])
  init_params_2 = np.random.uniform(0, np.pi, 2 * p)
  init_params_3 = fourier_init(p, freq=1)
  init_params_4 = problem_informed_init(p)
  init_params = init_params_4

  avg_profit = np.mean(np.diag(P))
  avg_weight = np.mean(w)
  gamma_init = 0.5 * np.arcsin(np.sqrt(C / (avg_weight * len(w))))  # ~0.2-0.5
  beta_init = np.pi / 4  # Maximal mixing
  #init_params = np.concatenate([np.full(p, gamma_init), np.full(p, beta_init)])
  print("Initial parameters:", init_params)

  start_time = time.time()
  result = minimize(expectation, init_params, method='COBYLA')
  runtime = time.time() - start_time

  #samples = cudaq.sample(qaoa_ansatz, result.x[0], result.x[1], shots = num_shots )
  # Split the optimized parameters into gammas and betas
  optimized_gammas = result.x[:p]
  optimized_betas = result.x[p:]

  samples = cudaq.sample(qaoa_ansatz, optimized_gammas, optimized_betas, coefficients["linear_x"],
        coefficients["linear_s"],
        coefficients["quad_xx"],
        coefficients["quad_xs"],
        coefficients["quad_ss"],
        p,
        shots_count=num_shots,)
  # Process results
  best_sample = max(samples.items(), key=lambda x: x[1])[0]
  selected_indices = [i for i, bit in enumerate(best_sample) if bit == '1']
  new_indices = [i for i in selected_indices if i < len(w)]
  total_weight = sum(w[i] for i in new_indices)
  total_profit = sum(P[i][j] for i in new_indices for j in new_indices)

  return new_indices, total_weight, total_profit, runtime, result.fun

selected_indices, total_weight, total_profit, runtime, best_energy= solve_qkp_with_QAOA(P, w, C, coefficients, p = 2)

print("Selected items:", selected_indices)
print(f"Total weight: {total_weight} / {C} ({'Feasible' if total_weight <= C else 'Infeasible'})")
print("Total profit:", total_profit)
print(f"Runtime: {runtime:.2f} seconds")
print("Best energy:", best_energy)